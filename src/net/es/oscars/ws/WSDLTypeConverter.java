/**
 * Type converter between Axis2 classes and Hibernate beans.
 *
 * @author David Robertson, Mary Thompson, Jason Lee
 */
package net.es.oscars.ws;

import java.util.*;

import org.apache.log4j.*;

// code generated by Martin Swany's schemas
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneDomainContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneHopContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneLinkContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneNodeContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePathContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePortContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwcapContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfo;

import net.es.oscars.bss.Reservation;
import net.es.oscars.bss.Token;
import net.es.oscars.bss.HashMapTypeConverter;
import net.es.oscars.bss.BSSException;
import net.es.oscars.bss.BssUtils;
import net.es.oscars.bss.topology.*;
import net.es.oscars.wsdlTypes.*;

/**
 * Has methods to convert between Axis2 WSDL type classes and Hibernate beans.
 * Used by both the API and the WBUI.
 */
public class WSDLTypeConverter {

    final public static String DEFAULT_TE_METRIC = "10";
    private static Logger log = Logger.getLogger(WSDLTypeConverter.class);

    // do not instantiate
    private WSDLTypeConverter() {
    }

    /**
     * Builds Hibernate Reservation bean, given Axis2 ResCreateContent class.
     *
     * @param params ResCreateContent instance
     * @return A Hibernate Reservation instance
     * @throws BSSException
     */
    public static Reservation contentToReservation(ResCreateContent params)
            throws BSSException {

        Reservation resv = new Reservation();
        PathInfo pathInfo = params.getPathInfo();
        Layer2Info layer2Info = pathInfo.getLayer2Info();
        Layer3Info layer3Info = pathInfo.getLayer3Info();
        // have to do error checking here because tooling doesn't handle
        // WSDL choice elements yet
        if ((layer2Info == null) && (layer3Info == null)) {
            throw new BSSException("No path information provided");
        } else if ((layer2Info != null) && (layer3Info != null)) {
            throw new BSSException(
                    "Cannot provide both layer 2 and layer 3 information");
        }
        Long startTime = params.getStartTime();
        Long endTime = params.getEndTime();
        long currentTime = System.currentTimeMillis() / 1000;
        // somewhat arbitrary; could be clock skew between client and server
        if ((startTime - currentTime) < -240L) {
            throw new BSSException(
                    "Start time is more than 4 minutes in the past: check your system time or client settings");
        }
        if (startTime >= endTime) {
            throw new BSSException(
                    "End time must be greater than start time");
        }
        resv.setStartTime(startTime);
        resv.setEndTime(endTime);
        Long bandwidth = new Long(
                Long.valueOf((long)params.getBandwidth() * 1000000L));
        resv.setBandwidth(bandwidth);
        resv.setDescription(params.getDescription());
        resv.setGlobalReservationId(params.getGlobalReservationId());

        return resv;
    }

    /**
     * Builds Hibernate Reservation bean, given Axis2 ResCreateContent class.
     *
     * @param params ResCreateContent instance
     * @return A Hibernate Reservation instance
     * @throws BSSException
     */
    public static Reservation contentToReservation(ModifyResContent params)
            throws BSSException {

        Reservation resv = new Reservation();

        // Hibernate will pick up error if any properties are null that
        // the database schema says cannot be null
        resv.setStartTime(params.getStartTime());
        resv.setEndTime(params.getEndTime());
        Long bandwidth = new Long(Long.valueOf((long)params.getBandwidth() * 1000000L));
        resv.setBandwidth(bandwidth);
        resv.setDescription(params.getDescription());
        resv.setGlobalReservationId(params.getGlobalReservationId());

        return resv;
    }

    /**
     * Builds Axis2 ModifyResReply class, given Hibernate Reservation bean.
     *
     * @param resv A Hibernate Reservation instance
     * @return CreateReply instance
     */
    public static ModifyResReply reservationToModifyReply(Reservation resv) throws BSSException {
        log.debug("reservationToModReply.start");

        ModifyResReply reply = new ModifyResReply();
        ResDetails details = WSDLTypeConverter.reservationToDetails(resv, false);
        reply.setReservation(details);
        log.debug("reservationToModReply.end");
        return reply;
    }



    /**
     * Builds Axis2 CreateReply class, given Hibernate Reservation bean.
     *
     * @param resv A Hibernate Reservation instance
     * @return CreateReply instance
     */
    public static CreateReply reservationToReply(Reservation resv) {
        CreateReply reply = new CreateReply();
        Token token = resv.getToken();

        reply.setGlobalReservationId(resv.getGlobalReservationId());
        if(token != null){
            reply.setToken(token.getValue());
        }else{
            reply.setToken("none");
        }
        reply.setStatus(resv.getStatus());
        return reply;
    }

    /**
     * Builds Axis2 ResDetails class, given Hibernate bean.
     * Note that this is used by only by query, and is using
     * information from a stored reservation.
     *
     * @param resv A Hibernate reservation instance
     * @return ResDetails instance
     */
    public static ResDetails
        reservationToDetails(Reservation resv, boolean internalPathAuthorized)
            throws BSSException{

        log.debug("reservationToDetails.start");
        if (resv == null) {
            log.debug("reservationToDetails.end (null)");
            return null;
        }

        ResDetails reply = new ResDetails();
        reply.setGlobalReservationId(resv.getGlobalReservationId());
            reply.setLogin(resv.getLogin());
        reply.setStatus(resv.getStatus());
        reply.setStartTime(resv.getStartTime());
        reply.setEndTime(resv.getEndTime());
        reply.setCreateTime(resv.getCreatedTime());
        Long mbps = resv.getBandwidth()/1000000;
        int bandwidth = mbps.intValue();
        reply.setBandwidth(bandwidth);
        reply.setDescription(resv.getDescription());
        PathInfo pathInfo =
            WSDLTypeConverter.getPathInfo(resv, null, internalPathAuthorized);
        reply.setPathInfo(pathInfo);
        log.debug("reservationToDetails.end");
        return reply;
    }

    /**
     * Builds list of Axis2 ListReply instances, given list of Hibernate
     * Reservation beans and a list of PathInfo structures.
     *
     * @param reservations A list of Hibernate Reservation beans
     * @return ListReply A list of Axis2 ListReply instances
     */
    public static ListReply
        reservationToListReply(List<Reservation> reservations,
                               boolean internalPathAuthorized)
            throws BSSException {

        ListReply reply = new ListReply();
        int ctr = 0;

        if ((reservations == null) || reservations.isEmpty()) {
            log.info("toListReply, reservations is null or empty");
            reply.setTotalResults(0);
            return reply;
        }

        int listLength = reservations.size();
        ResDetails[] resList = new ResDetails[listLength];
        reply.setTotalResults(listLength);

        for (Reservation resv : reservations) {
            ResDetails details =
                WSDLTypeConverter.reservationToDetails(resv,
                                                       internalPathAuthorized);
            resList[ctr] = details;
            ctr++;
        }
        reply.setResDetails(resList);
        return reply;
    }


    /**
     * Builds all components of Axis2 PathInfo structure, given a
     * Hibernate Reservation bean.
     *
     * @param resv a Reservation instance
     * @return pathInfo a filled in PathInfo Axis2 type
     */
    public static PathInfo getPathInfo(Reservation resv,
                                       String pathType,
                                       boolean internalPathAuthorized)
            throws BSSException {

        log.debug("getPathInfo.start");
        PathInfo pathInfo = new PathInfo();
        Path path = null;
        if (pathType != null) {
            path = resv.getPath(pathType);
        } else {
            path = BssUtils.getPath(resv);
            pathType = path.getPathType();
        }
        if (path != null) {
            pathInfo.setPathSetupMode(path.getPathSetupMode());
            // this may look at all three types of path
            pathInfo.setPath(pathToCtrlPlane(resv, pathType,
                                             internalPathAuthorized));
            // one of these is allowed to be null
            Layer2Info layer2Info = pathToLayer2Info(path);
            pathInfo.setLayer2Info(layer2Info);
            Layer3Info layer3Info = pathToLayer3Info(path);
            pathInfo.setLayer3Info(layer3Info);
            // allowed to be null
            MplsInfo mplsInfo = pathToMplsInfo(path);
            pathInfo.setMplsInfo(mplsInfo);
            log.debug("getPathInfo.end");
            return pathInfo;
        } else {
            throw new BSSException("path: " + pathType + " does not exist");
        }
    }

    /**
     * Builds Axis2 CtrlPlanePathContent, given Hibernate Reservation bean with
     * information retrieved from database.  TODO:  The path is built up given
     * a set of paths and the user's authorization.  If a path contains
     * internal hops, for example a requested path, and the user viewing
     * the reservation is not authorized, the internal hops are not returned.
     * If the user is authorized and both the local and interdomain paths
     * exist, the paths are combined and returned.  If only the local
     * path exists, hops are returned depending on the user's
     * authorization.
     *
     * @param resv a Reservation instance with a set of paths
     * @return A CtrlPlanePathContent instance
     * @throws BSSException 
     */
    public static CtrlPlanePathContent
        pathToCtrlPlane(Reservation resv, String pathType,
                        boolean internalPathAuthorized)
            throws BSSException {

        log.debug("pathToCtrlPlane.start");
        Path path = resv.getPath(pathType);
        List<PathElem> pathElems = path.getPathElems();
        CtrlPlanePathContent ctrlPlanePath = new CtrlPlanePathContent();
        int ctr = 1;
        for (PathElem pathElem: pathElems) {
            // TODO:  not final reorganization
            CtrlPlaneHopContent hop = WSDLTypeConverter.convertHop(pathElem, ctr);
            ctrlPlanePath.addHop(hop);
            ctr++;
        }
        ctrlPlanePath.setId("unimplemented");
        log.debug("pathToCtrlPlane.end");
        return ctrlPlanePath;
    }

    /**
     * Fills in Axis2 CtrlPlaneHopContent, given a Hibernate PathElem bean.
     * @param pathElem Hibernate PathElem instance
     * @param ctr hop number
     * @return A CtrlPlaneHopContent instance
     * @throws BSSException 
     */
    public static CtrlPlaneHopContent convertHop(PathElem pathElem, int ctr)
            throws BSSException {

        log.debug("convertHop.start");
        CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
        CtrlPlaneLinkContent cpLink = new CtrlPlaneLinkContent();
        CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
        CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo =
                                new CtrlPlaneSwitchingCapabilitySpecificInfo();
        Link link = pathElem.getLink();
        String urn = pathElem.getUrn();
        if ((urn == null) || urn.trim().equals("")) {
            if (link != null) {
                // TODO: if could convert existing paths, would not need this
                urn = link.getFQTI();
            } else {
                urn = "";
            }
        }
        Hashtable<String, String> parseResults = URNParser.parseTopoIdent(urn);
        String hopType = parseResults.get("type");
        hop.setId(ctr + "");
            
        /* Handle case where unconfirmed path contains domain, node, 
         * port, or link id refs */
        if ("domain".equals(hopType)) {
            hop.setDomainIdRef(urn);
            return hop;
        } else if("node".equals(hopType)) {
            hop.setNodeIdRef(urn);
            return hop;
        } else if("port".equals(hopType)) {
            hop.setPortIdRef(urn);
            return hop;
        } else if (link == null && pathElem.getPathElemParams().isEmpty()) {
            /* if a link URN not in the local domain and we don't have 
             * params for it then must be a <linkIdRef> */
            hop.setLinkIdRef(urn);
            return hop;
        }
            
        /* If reach this point then we have a <link> to create.. */
        if (link == null) {
            cpLink.setTrafficEngineeringMetric(
                    WSDLTypeConverter.DEFAULT_TE_METRIC);
        } else {
            cpLink.setTrafficEngineeringMetric(
                    link.getTrafficEngineeringMetric());
        }
            
        PathElemParam vlanRange =
            pathElem.getPathElemParam(PathElemParamSwcap.L2SC,
                                      PathElemParamType.L2SC_VLAN_RANGE);
        PathElemParam suggVlan =
            pathElem.getPathElemParam(PathElemParamSwcap.L2SC,
                                      PathElemParamType.L2SC_SUGGESTED_VLAN);
        if (vlanRange == null) {
            swcap.setSwitchingcapType(L2SwitchingCapType.DEFAULT_SWCAP_TYPE);
            swcap.setEncodingType(L2SwitchingCapType.DEFAULT_ENC_TYPE);
            swcapInfo.setCapability("unimplemented");
        } else {
            swcap.setSwitchingcapType(PathElemParamSwcap.L2SC);
            swcap.setEncodingType("ethernet");
            swcapInfo.setInterfaceMTU(L2SwitchingCapType.DEFAULT_MTU);
            swcapInfo.setVlanRangeAvailability(vlanRange.getValue());
            if (suggVlan != null) {
                swcapInfo.setSuggestedVLANRange(suggVlan.getValue());
            }
        }
        swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
        cpLink.setId(urn);
        cpLink.setSwitchingCapabilityDescriptors(swcap);
        hop.setLink(cpLink);
        log.debug("convertHop.end");
        return hop;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for layer 2 information.
     */
    public static Layer2Info pathToLayer2Info(Path path) {
        log.debug("pathToLayer2Info.start");
        // database type
        Layer2Data layer2Data = path.getLayer2Data();
        if (layer2Data == null) {
            return null;
        }

        // Axis2 type
        Layer2Info layer2Info = new Layer2Info();
        layer2Info.setSrcEndpoint(layer2Data.getSrcEndpoint());
        layer2Info.setDestEndpoint(layer2Data.getDestEndpoint());

        log.debug("pathToLayer2Info.end");
        return layer2Info;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for layer 3 information.
     */
    public static Layer3Info pathToLayer3Info(Path path) {
        log.debug("pathToLayer3Info.start");

        // database type
        Layer3Data layer3Data = path.getLayer3Data();
        if (layer3Data == null) {
            return null;
        }
        // Axis2 type
        Layer3Info layer3Info = new Layer3Info();
        layer3Info.setSrcHost(layer3Data.getSrcHost());
        layer3Info.setDestHost(layer3Data.getDestHost());
        // makes sure that protocol is in upper case to match WSDL
        if (layer3Data.getProtocol() != null) {
            layer3Info.setProtocol(layer3Data.getProtocol().toUpperCase());
        }
        if (layer3Data.getSrcIpPort() != null) {
            layer3Info.setSrcIpPort(layer3Data.getSrcIpPort());
        }
        if (layer3Data.getDestIpPort() != null) {
            layer3Info.setDestIpPort(layer3Data.getDestIpPort());
        }
        log.debug("pathToLayer3Info.end");

        return layer3Info;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for MPLS information.
     */
    public static MplsInfo pathToMplsInfo(Path path) {
        log.debug("pathToMplsInfo.start");

        // database type
        MPLSData mplsData = path.getMplsData();
        if (mplsData == null) {
            return null;
        }
        // Axis2 type
        MplsInfo mplsInfo = new MplsInfo();
        int burstLimit = mplsData.getBurstLimit().intValue();
        mplsInfo.setBurstLimit(burstLimit);
        mplsInfo.setLspClass(mplsData.getLspClass());
        log.debug("pathToMplsInfo.end");
        return mplsInfo;
    }

    /**
     * Converts a hash map to a ResDetail object for Axis2
     *
     * @param map a HashMap with reservation information
     * @return the converted HashMap in a ResDetails object
     */
    public static ResDetails hashMapToResDetails(HashMap<String, String[]> map){
        //Verify that map has enough fields to build valid ResDetails object
        final String[] requiredFields = { "gri", "userLogin", "status",
                                          "startSeconds", "endSeconds",
                                          "createSeconds", "bandwidth",
                                          "description", "pathSetupMode" };
        if(map == null){ return null; }
        for(int i = 0; i < requiredFields.length; i++){
            if(map.get(requiredFields[i]) == null){
                return null;
            }
        }

        //If everything looks good then build the object
        ResDetails details = new ResDetails();
        PathInfo pathInfo = new PathInfo();
        boolean hasLayer2Params = false;
        boolean hasLayer3Params = false;
        details.setGlobalReservationId(HashMapTypeConverter.extractHashVal(map.get("gri")));
        details.setLogin(HashMapTypeConverter.extractHashVal(map.get("userLogin")));
        details.setStatus(HashMapTypeConverter.extractHashVal(map.get("status")));
        details.setStartTime(HashMapTypeConverter.extractHashLongVal(map.get("startSeconds")));
        details.setEndTime(HashMapTypeConverter.extractHashLongVal(map.get("endSeconds")));
        details.setCreateTime(HashMapTypeConverter.extractHashLongVal(map.get("createTime")));
        details.setBandwidth(HashMapTypeConverter.extractHashIntVal(map.get("bandwidth")));
        details.setDescription(HashMapTypeConverter.extractHashVal(map.get("description")));

        pathInfo.setPathSetupMode(HashMapTypeConverter.extractHashVal(map.get("pathSetupMode")));
        pathInfo.setPathType(HashMapTypeConverter.extractHashVal(map.get("pathType")));

        /*Set Path
           use interdomain path if available otherwise just use the
           intradomain path. If this will be used in an idc:event
           object then the intradomain path will also be included in
           /idc:event/idc:localDetails */
        String[] path = map.get("interdomainPath");
        String[] hopInfo = map.get("interdomainHopInfo");
        String[] intra = map.get("intradomainPath");
        String[] intraHopInfo = map.get("intradomainHopInfo");
        //if no interdomain path show the local ingress/egress
        /* TODO: Conversion from intradomain to interdomain should be done
            in domain-specific module like Pathfinder */
        if(path == null && intra != null && intra.length == 1){
            path = intra;
            hopInfo = intraHopInfo;
        }else if(path == null && intra != null && intra.length > 1){
            path = new String[2];
            path[0] = intra[0];
            path[1] = intra[intra.length-1];
            hopInfo[0] = intraHopInfo[0];
            hopInfo[1] = intraHopInfo[intraHopInfo.length-1];
        }
        if(path != null){
            CtrlPlanePathContent wsPath = arrayToCtrlPlanePath(path, hopInfo);
            pathInfo.setPath(wsPath);
        }

        //Get layers
        String[] layers = map.get("layer");
        for(int i = 0; layers!= null && i < layers.length; i++){
            if("2".equals(layers[i])){
                hasLayer2Params = true;
            }else if("3".equals(layers[i])){
                hasLayer3Params = true;
            }
        }

        if(hasLayer2Params){
            Layer2Info layer2Info = new Layer2Info();
            String srcVtagStr = HashMapTypeConverter.extractHashVal(map.get("srcVtag"));
            String destVtagStr = HashMapTypeConverter.extractHashVal(map.get("destVtag"));
            layer2Info.setSrcEndpoint(HashMapTypeConverter.extractHashVal(map.get("source")));
            layer2Info.setDestEndpoint(HashMapTypeConverter.extractHashVal(map.get("destination")));
            if(srcVtagStr != null){
                VlanTag vtag = new VlanTag();
                String isTagged = HashMapTypeConverter.extractHashVal(map.get("tagSrcPort"));
                vtag.setString(srcVtagStr);
                vtag.setTagged(isTagged!= null && "true".equals(isTagged));
                layer2Info.setSrcVtag(vtag);
            }
            if(destVtagStr != null){
                VlanTag vtag = new VlanTag();
                String isTagged = HashMapTypeConverter.extractHashVal(map.get("tagDestPort"));
                vtag.setString(destVtagStr);
                vtag.setTagged(isTagged!= null && "true".equals(isTagged));
                layer2Info.setDestVtag(vtag);
            }
            pathInfo.setLayer2Info(layer2Info);
        }

        if(hasLayer3Params){
            Layer3Info layer3Info = new Layer3Info();
            layer3Info.setSrcHost(HashMapTypeConverter.extractHashVal(map.get("source")));
            layer3Info.setDestHost(HashMapTypeConverter.extractHashVal(map.get("destination")));
            layer3Info.setProtocol(HashMapTypeConverter.extractHashVal(map.get("protocol")));
            layer3Info.setSrcIpPort(HashMapTypeConverter.extractHashIntVal(map.get("srcPort")));
            layer3Info.setDestIpPort(HashMapTypeConverter.extractHashIntVal(map.get("destPort")));
            layer3Info.setDscp(HashMapTypeConverter.extractHashVal(map.get("dscp")));
            pathInfo.setLayer3Info(layer3Info);
        }

        int burstLimit = HashMapTypeConverter.extractHashIntVal(map.get("burstLimit"));
        String lspClass = HashMapTypeConverter.extractHashVal(map.get("lspClass"));
        if(burstLimit != 0 || lspClass != null){
            MplsInfo mplsInfo = new MplsInfo();
            mplsInfo.setLspClass(lspClass);
            mplsInfo.setBurstLimit(burstLimit);
            pathInfo.setMplsInfo(mplsInfo);
        }

        details.setPathInfo(pathInfo);

        return details;
    }

    /**
     * Converts a string array of a path and its corresponding array of hop
     * details to a CtrlPlanePathContent object.
     *
     * @param path the path to convert as an array of URNs
     * @param hopInfo the details of each hop in the path
     * @return the converted CtrlPlanePathContent
     */
     public static CtrlPlanePathContent arrayToCtrlPlanePath(String[] path, String[] hopInfo){
        CtrlPlanePathContent wsPath = new CtrlPlanePathContent();
        wsPath.setId("resvPath");
        for(int i = 0; i < path.length; i++){
            CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
            hop.setId((i+1) + "");
            Hashtable<String, String> parseResults = URNParser.parseTopoIdent(path[i]);
            String hopType = parseResults.get("type");
            if("link".equals(hopType) && "".equals(hopInfo[i])){
                hop.setLinkIdRef(path[i]);
            }else if("link".equals(hopType)){
                CtrlPlaneLinkContent link = new CtrlPlaneLinkContent();
                link.setId(path[i]);
                String[] infoVals = hopInfo[i].split(";");
                link.setTrafficEngineeringMetric(infoVals[0] + "");
                CtrlPlaneSwcapContent linkSwcap = new CtrlPlaneSwcapContent();
                linkSwcap.setSwitchingcapType(infoVals[1]);
                linkSwcap.setEncodingType(infoVals[2]);
                CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                if("l2sc".equals(infoVals[1])){
                    swcapInfo.setInterfaceMTU("null".equals(infoVals[3]) ? 0 : Integer.parseInt(infoVals[3]));
                    swcapInfo.setVlanRangeAvailability("null".equals(infoVals[4]) ? null : infoVals[4]);
                    swcapInfo.setSuggestedVLANRange("null".equals(infoVals[5]) ? null : infoVals[5]);
                }else{
                   swcapInfo.setCapability("null".equals(infoVals[3]) ? null : infoVals[3]);
                }
                linkSwcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                link.setSwitchingCapabilityDescriptors(linkSwcap);
                hop.setLink(link);
            }else if("port".equals(hopType)){
                /* we don't define how port, node, and domain objects are used
                   in path yet so just use idrefs */
                hop.setPortIdRef(path[i]);
            }else if("node".equals(hopType)){
                hop.setNodeIdRef(path[i]);
            }else if("domain".equals(hopType)){
                hop.setDomainIdRef(path[i]);
            }

            wsPath.addHop(hop);
        }
        return wsPath;
     }

    /**
     * Converts an incoming Axis2 PathInfo object into a Hibernate Path object.
     *
     * @param requestedPath PathInfo instance (Axis2 type) with filled in info
     * @return path Path in database format
     */
    public static Path convertPath(PathInfo pathInfo) throws BSSException {

        log.debug("convertPath.start");
        Path path = new Path();
        path.setPathType(PathType.REQUESTED);
        path.setPathSetupMode(pathInfo.getPathSetupMode());
        path.setPathHopType(pathInfo.getPathType());
        Layer2Info layer2Info = pathInfo.getLayer2Info();
        Layer3Info layer3Info = pathInfo.getLayer3Info();
        MplsInfo mplsInfo = pathInfo.getMplsInfo();
        if (layer2Info != null) {
            Layer2Data dbLayer2Data = layer2InfoToData(layer2Info);
            path.setLayer2Data(dbLayer2Data);
        } else if (layer3Info != null) {
            Layer3Data dbLayer3Data = layer3InfoToData(layer3Info);
            path.setLayer3Data(dbLayer3Data);
        }
        if (mplsInfo != null) {
            MPLSData dbMplsData = mplsInfoToData(mplsInfo);
            path.setMplsData(dbMplsData);
        }
        CtrlPlanePathContent requestedPath = pathInfo.getPath();
        CtrlPlaneHopContent[] hops = requestedPath.getHop();
        List<PathElem> pathElems = new ArrayList<PathElem>();

        for (int i = 0; i < hops.length; i++) {
            PathElem pathElem = new PathElem();
            CtrlPlaneLinkContent link = hops[i].getLink();
            if (link != null) {
                List<PathElemParam> pathElemParams =
                    convertCtrlPlaneLink(link);
                for (PathElemParam pep: pathElemParams) {
                    pathElem.addPathElemParam(pep);
                }
            }
            String urn = hopToURN(hops[i], "any");
            pathElem.setUrn(urn);
            pathElems.add(pathElem);
        }
        path.setPathElems(pathElems);
        log.debug("convertPath.end");
        return path;
    }

    public static List<PathElemParam>
        convertCtrlPlaneLink(CtrlPlaneLinkContent link) {

        List<PathElemParam> pathElemParams = new ArrayList<PathElemParam>();
        CtrlPlaneSwcapContent swcap = link.getSwitchingCapabilityDescriptors();
        String switchingcapType = swcap.getSwitchingcapType();
        CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = 
                            swcap.getSwitchingCapabilitySpecificInfo();
        if (swcapInfo.getVlanRangeAvailability() != null) {
            PathElemParam pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType("vlanRangeAvailability");
            pathElemParam.setValue(swcapInfo.getVlanRangeAvailability());
            pathElemParams.add(pathElemParam);
        }
        if (swcapInfo.getSuggestedVLANRange() != null) {
            PathElemParam pathElemParam = new PathElemParam();
            pathElemParam.setSwcap(switchingcapType);
            pathElemParam.setType("suggestedVlanRange");
            pathElemParam.setValue(swcapInfo.getSuggestedVLANRange());
            pathElemParams.add(pathElemParam);
        }
        return pathElemParams;
    }

    /**
     * Converts Axis2 Layer2Info object to a Layer2Data Hibernate bean
     *
     * @param layer2Info the Layer2Info object to convert
     * @return the converted Layer2Data bean
     */
     public static Layer2Data layer2InfoToData(Layer2Info layer2Info){
        if(layer2Info == null){
            return null;
        }
        Layer2Data layer2Data = new Layer2Data();
        layer2Data.setSrcEndpoint(layer2Info.getSrcEndpoint());
        layer2Data.setDestEndpoint(layer2Info.getDestEndpoint());

        return layer2Data;
     }

     /**
     * Converts Axis2 Layer3Info object to a Layer3Data Hibernate bean
     *
     * @param layer3Info the Layer3Info object to convert
     * @return the converted Layer3Data bean
     */
     public static Layer3Data layer3InfoToData(Layer3Info layer3Info){
        if(layer3Info == null){
            return null;
        }
        Layer3Data layer3Data = new Layer3Data();

        layer3Data.setSrcHost(layer3Info.getSrcHost());
        layer3Data.setDestHost(layer3Info.getDestHost());
        layer3Data.setSrcIpPort(layer3Info.getSrcIpPort());
        layer3Data.setDestIpPort(layer3Info.getDestIpPort());
        layer3Data.setProtocol(layer3Info.getProtocol());
        layer3Data.setDscp(layer3Info.getDscp());

        return layer3Data;
     }

     /**
     * Converts Axis2 MplsInfo object to a MPLSData Hibernate bean
     *
     * @param mplsInfo the MplsInfo object to convert
     * @return the converted MPLSData bean
     */
     public static MPLSData mplsInfoToData(MplsInfo mplsInfo){
        if(mplsInfo == null){
            return null;
        }
        MPLSData mplsData = new MPLSData();

        mplsData.setBurstLimit((long) mplsInfo.getBurstLimit());
        mplsData.setLspClass(mplsInfo.getLspClass());

        return mplsData;
     }

     /**
     * Returns the URN of the any type based on the hop object ID or
     * IDRef field. Also does some validation Axis2 is missing.
     *
     * @param hop the CtrlPlaneHopContent to parse
     * @return the domain,node,port or link URN of the hop, null if invalid hop
     */
    public static String hopToURN(CtrlPlaneHopContent hop){
        return hopToURN(hop, "any");
    }

     /**
     * Returns the URN of the given type based on the hop object ID or
     * IDRef field. Also does some validation Axis2 is missing.
     *
     * @param hop the CtrlPlaneHopContent to parse
     * @param type string with type of hop
     * @return the domain,node,port or link URN of the hop, null if invalid hop
     */
    public static String hopToURN(CtrlPlaneHopContent hop, String type){
        if(hop == null){
            return null;
        }
        if(type == null || !("link".equals(type) || "any".equals(type) ||
           "port".equals(type) || "node".equals(type) || "domain".equals(type))){
            return null;
        }
        String urn = null;
        int urnType = 0;
        int childCount = 0;

        String linkIdRef = hop.getLinkIdRef();
        if(linkIdRef != null){
            urn = linkIdRef;
            urnType = 1;
            childCount++;
        }
        CtrlPlaneLinkContent link = hop.getLink();
        if(link != null){
            urn = link.getId();
            urnType = 1;
            childCount++;
        }
        if("link".equals(type)){
            return urn;
        }

        String portIdRef = hop.getPortIdRef();
        if(portIdRef != null){
            urn = portIdRef;
            urnType = 2;
            childCount++;
        }
        CtrlPlanePortContent port = hop.getPort();
        if(port != null){
            urn = port.getId();
            urnType = 2;
            childCount++;
        }
        if("port".equals(type) && urnType == 2){
            return urn;
        }else if(urnType == 2){
            return null;
        }

        String nodeIdRef = hop.getNodeIdRef();
        if(nodeIdRef != null){
            urn = nodeIdRef;
            urnType = 3;
            childCount++;
        }
        CtrlPlaneNodeContent node = hop.getNode();
        if(node != null){
            urn = node.getId();
            urnType = 3;
            childCount++;
        }
        if("node".equals(type) && urnType == 3){
            return urn;
        }else if(urnType == 3){
            return null;
        }

        String domainIdRef = hop.getDomainIdRef();
        if(domainIdRef != null){
            urn = domainIdRef;
            urnType = 4;
            childCount++;
        }
        CtrlPlaneDomainContent domain = hop.getDomain();
        if(domain != null){
            urn = domain.getId();
            urnType = 4;
            childCount++;
        }
        if("domain".equals(type) && urnType == 4){
            return urn;
        }else if(urnType == 4){
            return null;
        }

        /* we have to tcheck errors ourselves because xsd:choice
          elements are clunky in Axis2 */
        if(urn == null){
            log.debug("Empty hop");
        }else if(childCount > 1){
            log.debug("Parse error: Hop must contain only one " +
                           "domain, node, port or link object/reference");
            urn = null;
        }
        return urn;
    }
}
