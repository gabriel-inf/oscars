/**
 * Type converter between Axis2 classes and Hibernate beans.
 *
 * @author David Robertson, Mary Thompson, Jason Lee
 */
package net.es.oscars.oscars;

import java.util.*;
import java.net.InetAddress;
import java.net.UnknownHostException;

import org.apache.log4j.*;

// code generated by Martin Swany's schemas
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneDomainContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneHopContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneLinkContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneNodeContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePathContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePortContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwcapContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfo;

import net.es.oscars.bss.Reservation;
import net.es.oscars.bss.Token;
import net.es.oscars.bss.PathManager;
import net.es.oscars.bss.BSSException;
import net.es.oscars.bss.topology.*;
import net.es.oscars.wsdlTypes.*;

/**
 * Has methods to convert between Axis2 WSDL type classes and Hibernate beans.
 * Used by both the API and the WBUI.
 */
public class TypeConverter {

    private static Logger log = Logger.getLogger(TypeConverter.class);

    // do not instantiate
    private TypeConverter() {
    }

    /**
     * Builds Hibernate Reservation bean, given Axis2 ResCreateContent class.
     *
     * @param params ResCreateContent instance
     * @return A Hibernate Reservation instance
     * @throws BSSException
     */
    public static Reservation contentToReservation(ResCreateContent params)
            throws BSSException {

        Reservation resv = new Reservation();
        PathInfo pathInfo = params.getPathInfo();
        Layer2Info layer2Info = pathInfo.getLayer2Info();
        Layer3Info layer3Info = pathInfo.getLayer3Info();
        // have to do error checking here because tooling doesn't handle
        // WSDL choice elements yet
        if ((layer2Info == null) && (layer3Info == null)) {
            throw new BSSException("No path information provided");
        } else if ((layer2Info != null) && (layer3Info != null)) {
            throw new BSSException(
                    "Cannot provide both layer 2 and layer 3 information");
        }
        Long startTime = params.getStartTime();
        Long endTime = params.getEndTime();
        long currentTime = System.currentTimeMillis() / 1000;
        // somewhat arbitrary; could be clock skew between client and server
        if ((startTime - currentTime) < -240L) {
            throw new BSSException(
                    "Start time is more than 4 minutes in the past: check your system time or client settings");
        }
        if (startTime >= endTime) {
            throw new BSSException(
                    "End time must be greater than start time");
        }
        resv.setStartTime(startTime);
        resv.setEndTime(endTime);
        Long bandwidth = new Long(
                Long.valueOf((long)params.getBandwidth() * 1000000L));
        resv.setBandwidth(bandwidth);
        resv.setDescription(params.getDescription());
        resv.setGlobalReservationId(params.getGlobalReservationId());

        return resv;
    }

    /**
     * Builds Hibernate Reservation bean, given Axis2 ResCreateContent class.
     *
     * @param params ResCreateContent instance
     * @return A Hibernate Reservation instance
     * @throws BSSException
     */
    public static Reservation contentToReservation(ModifyResContent params)
            throws BSSException {

        Reservation resv = new Reservation();

        // Hibernate will pick up error if any properties are null that
        // the database schema says cannot be null
        resv.setStartTime(params.getStartTime());
        resv.setEndTime(params.getEndTime());
        Long bandwidth = new Long(Long.valueOf((long)params.getBandwidth() * 1000000L));
        resv.setBandwidth(bandwidth);
        resv.setDescription(params.getDescription());
        resv.setGlobalReservationId(params.getGlobalReservationId());

        return resv;
    }

    /**
     * Builds Axis2 ModifyResReply class, given Hibernate Reservation bean.
     *
     * @param resv A Hibernate Reservation instance
     * @return CreateReply instance
     */
    public static ModifyResReply reservationToModifyReply(Reservation resv) throws BSSException {
        log.debug("reservationToModReply.start");

        ModifyResReply reply = new ModifyResReply();
        ResDetails details = TypeConverter.reservationToDetails(resv);
        reply.setReservation(details);
        log.debug("reservationToModReply.end");
        return reply;
    }



    /**
     * Builds Axis2 CreateReply class, given Hibernate Reservation bean.
     *
     * @param resv A Hibernate Reservation instance
     * @return CreateReply instance
     */
    public CreateReply reservationToReply(Reservation resv) {
        CreateReply reply = new CreateReply();
        Token token = resv.getToken();

        reply.setGlobalReservationId(resv.getGlobalReservationId());
        if(token != null){
            reply.setToken(token.getValue());
        }else{
            reply.setToken("none");
        }
        reply.setStatus(resv.getStatus());
        return reply;
    }

    /**
     * Builds Axis2 ResDetails class, given Hibernate bean.
     * Note that this is used by only by query, and is using
     * information from a stored reservation.
     *
     * @param resv A Hibernate reservation instance
     * @return ResDetails instance
     */
    public static ResDetails reservationToDetails(Reservation resv) throws BSSException{

        log.debug("reservationToDetails.start");
        if (resv == null) {
            log.debug("reservationToDetails.end (null)");
            return null;
        }

        ResDetails reply = new ResDetails();
        reply.setGlobalReservationId(resv.getGlobalReservationId());
            reply.setLogin(resv.getLogin());
        reply.setStatus(resv.getStatus());
        reply.setStartTime(resv.getStartTime());
        reply.setEndTime(resv.getEndTime());
        reply.setCreateTime(resv.getCreatedTime());
        Long mbps = resv.getBandwidth()/1000000;
        int bandwidth = mbps.intValue();
        reply.setBandwidth(bandwidth);
        reply.setDescription(resv.getDescription());
    	reply.setPathInfo(TypeConverter.getPathInfo(resv));
        log.debug("reservationToDetails.end");
        return reply;
    }

    /**
     * Builds list of Axis2 ListReply instances, given list of Hibernate
     * Reservation beans and a list of PathInfo structures.
     *
     * @param reservations A list of Hibernate Reservation beans
     * @return ListReply A list of Axis2 ListReply instances
     */
    public ListReply reservationToListReply(List<Reservation> reservations) throws BSSException {
        ListReply reply = new ListReply();
        int ctr = 0;

        if ((reservations == null) || reservations.isEmpty()) {
            this.log.info("toListReply, reservations is null or empty");
            reply.setTotalResults(0);
            return reply;
        }

        int listLength = reservations.size();
        ResDetails[] resList = new ResDetails[listLength];
        reply.setTotalResults(listLength);

        for (Reservation resv : reservations) {
            ResDetails details = this.reservationToDetails(resv);
            resList[ctr] = details;
            ctr++;
        }
        reply.setResDetails(resList);
        return reply;
    }


    /**
     * Builds all components of Axis2 PathInfo structure, given a
     * Hibernate Reservation bean.
     *
     * @param resv a Reservation instance
     * @return pathInfo a filled in PathInfo Axis2 type
     */
    public static PathInfo getPathInfo(Reservation resv) throws BSSException {
        log.debug("getPathInfo.start");
        PathInfo pathInfo = new PathInfo();
        Path path = resv.getPath(PathType.INTRADOMAIN);
        if (path != null) {
            pathInfo.setPathSetupMode(path.getPathSetupMode());
            pathInfo.setPath(pathToCtrlPlane(path, true));
            // one of these is allowed to be null
            Layer2Info layer2Info = pathToLayer2Info(path);
            pathInfo.setLayer2Info(layer2Info);
            Layer3Info layer3Info = pathToLayer3Info(path);
            pathInfo.setLayer3Info(layer3Info);
            // allowed to be null
            MplsInfo mplsInfo = pathToMplsInfo(path);
            pathInfo.setMplsInfo(mplsInfo);
            log.debug("getPathInfo.end");
            return pathInfo;
        } else {
            log.debug("getPathInfo.end");
            return null;
        }
    }

    /**
     * Takes a pathInfo object and sets the source and destination
     * to the ingress and egress. This makes it valid for pathfinders
     * testing whether src and dest are set as the first and last hops
     * in the path. Assumes that the path object contains the local
     * path segment.
     *
     * @param pathInfo the pathInfo instance to convert
     * @return the converted pathInfo object
     */
    public static PathInfo toLocalPathInfo(PathInfo pathInfo){
        Layer2Info l2Info = pathInfo.getLayer2Info();
        Layer3Info l3Info = pathInfo.getLayer3Info();
        CtrlPlanePathContent path = pathInfo.getPath();
        CtrlPlaneHopContent[] hop = path.getHop();
        String ingress = null;
        String egress = null;

        if(path == null){
            return pathInfo;
        }

        hop = path.getHop();
        if(hop == null){
            return pathInfo;
        }

        ingress = hopToURN(hop[0], "link");
        egress = hopToURN(hop[hop.length - 1], "link");
        if(l2Info != null){
            l2Info.setSrcEndpoint(ingress);
            l2Info.setDestEndpoint(egress);
            pathInfo.setLayer2Info(l2Info);
        }
        if(l3Info != null){
            l3Info.setSrcHost(ingress);
            l3Info.setDestHost(egress);
            pathInfo.setLayer3Info(l3Info);
        }

        return pathInfo;
    }

    /**
     * Builds Axis2 CtrlPlanePathContent, given Hibernate Path bean with
     * information retrieved from database.  This is the reservation's
     * internal path returned in response to a query.
     *
     * @param path a Path instance
     * @param confirmed true if result path should be a confirmed path
     * @return A CtrlPlanePathContent instance
     */
    public static CtrlPlanePathContent pathToCtrlPlane(Path path, boolean confirmed) {
        log.debug("pathToCtrlPlane.start");
        String swcapType = PathManager.DEFAULT_SWCAP_TYPE;
        String encType = PathManager.DEFAULT_ENC_TYPE;
        Ipaddr ipaddr = null;

        List<PathElem> pathElems = path.getPathElems();
        CtrlPlanePathContent ctrlPlanePath = new CtrlPlanePathContent();
        int i = 1;
        for (PathElem pathElem: pathElems) {
            CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
            CtrlPlaneLinkContent cpLink = new CtrlPlaneLinkContent();
            CtrlPlaneSwcapContent swcap = new CtrlPlaneSwcapContent();
            CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo =
                                new CtrlPlaneSwitchingCapabilitySpecificInfo();
            Link link = pathElem.getLink();
            String linkId = null;
            cpLink.setTrafficEngineeringMetric(link.getTrafficEngineeringMetric());
            if (path.getLayer2Data() != null) {
                linkId = link.getFQTI();
            } else {
                //TODO: This should be in an ESnet specific location
                String nodeName = link.getPort().getNode().getTopologyIdent();
                ipaddr = link.getValidIpaddr();
                if (ipaddr == null) {
                    linkId = "*out-of-date IP*";
                } else {
                    linkId = nodeName + ": " + ipaddr.getIP();
                }
            }
            L2SwitchingCapabilityData l2scData =
                                           link.getL2SwitchingCapabilityData();
            if(l2scData == null){
                swcap.setSwitchingcapType(swcapType);
                swcap.setEncodingType(encType);
                swcapInfo.setCapability("unimplemented");
            }else{
                swcap.setSwitchingcapType("l2sc");
                swcap.setEncodingType("ethernet");
                swcapInfo.setInterfaceMTU(l2scData.getInterfaceMTU());
                if(confirmed){
                    swcapInfo.setVlanRangeAvailability(pathElem.getLinkDescr());
                }else{
                    swcapInfo.setVlanRangeAvailability(l2scData.getVlanRangeAvailability());
                    swcapInfo.setSuggestedVLANRange(pathElem.getLinkDescr());
                }
            }
            swcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
            cpLink.setId(linkId);
            cpLink.setSwitchingCapabilityDescriptors(swcap);
            hop.setId(i + "");
            hop.setLink(cpLink);
            ctrlPlanePath.addHop(hop);
            i++;
        }
        ctrlPlanePath.setId("unimplemented");
        log.debug("pathToCtrlPlane.end");
        return ctrlPlanePath;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for layer 2 information.
     */
    public static Layer2Info pathToLayer2Info(Path path) {
        log.debug("pathToLayer2Info.start");
        // database type
        Layer2Data layer2Data = path.getLayer2Data();
        if (layer2Data == null) {
            return null;
        }

        // Axis2 type
        Layer2Info layer2Info = new Layer2Info();
        layer2Info.setSrcEndpoint(layer2Data.getSrcEndpoint());
        layer2Info.setDestEndpoint(layer2Data.getDestEndpoint());

        log.debug("pathToLayer2Info.end");
        return layer2Info;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for layer 3 information.
     */
    public static Layer3Info pathToLayer3Info(Path path) {
        log.debug("pathToLayer3Info.start");

        // database type
        Layer3Data layer3Data = path.getLayer3Data();
        if (layer3Data == null) {
            return null;
        }
        // Axis2 type
        Layer3Info layer3Info = new Layer3Info();
        layer3Info.setSrcHost(layer3Data.getSrcHost());
        layer3Info.setDestHost(layer3Data.getDestHost());
        // makes sure that protocol is in upper case to match WSDL
        if (layer3Data.getProtocol() != null) {
            layer3Info.setProtocol(layer3Data.getProtocol().toUpperCase());
        }
        if (layer3Data.getSrcIpPort() != null) {
            layer3Info.setSrcIpPort(layer3Data.getSrcIpPort());
        }
        if (layer3Data.getDestIpPort() != null) {
            layer3Info.setDestIpPort(layer3Data.getDestIpPort());
        }
        log.debug("pathToLayer3Info.end");

        return layer3Info;
    }

    /**
     * Given the Hibernate bean for a path, return a filled in Axis2 instance
     * for MPLS information.
     */
    public static MplsInfo pathToMplsInfo(Path path) {
        log.debug("pathToMplsInfo.start");

        // database type
        MPLSData mplsData = path.getMplsData();
        if (mplsData == null) {
            return null;
        }
        // Axis2 type
        MplsInfo mplsInfo = new MplsInfo();
        int burstLimit = mplsData.getBurstLimit().intValue();
        mplsInfo.setBurstLimit(burstLimit);
        mplsInfo.setLspClass(mplsData.getLspClass());
        log.debug("pathToMplsInfo.end");
        return mplsInfo;
    }

    public static void ensureLocalIds(PathInfo pathInfo) {
        if (pathInfo == null) {
            return;
        }

        CtrlPlanePathContent path = pathInfo.getPath();
        if (path == null) {
            return;
        }
        path.setId("unimplemented");

        CtrlPlaneHopContent[] hops = path.getHop();
        if (hops == null) {
            return;
        }
        for (int i=0; i < hops.length; i++) {
            CtrlPlaneHopContent hop = hops[i];
            if (hop.getId() == null || hop.getId().equals("")) {
                hop.setId(i+"");
            }
        }
        return;
    }

    /**
     * Given a PathInfo instance, converts the ERO to format for client.
     * Currently it is passed back as is for layer 2, and converted to host name
     * IP pairs for layer 3.  This is used by the create message.
     *
     * @param pathInfo a PathInfo instance
     */
    public static void clientConvert(PathInfo pathInfo) {
        log.debug("clientConvert.start");


        String hopId = null;
        String hostName = null;
        Ipaddr ipaddr = null;

        CtrlPlanePathContent oldPath = pathInfo.getPath();
        CtrlPlanePathContent newPath = new CtrlPlanePathContent();
        CtrlPlaneHopContent[] oldHops = oldPath.getHop();

        // return as is if layer 2; just fix hop id
        if (pathInfo.getLayer2Info() != null) {
            ensureLocalIds(pathInfo);
            return;
        }
        // if layer 3, generate new path with host name/IP rather than
        // topology identifier
        DomainDAO domainDAO =  new DomainDAO("bss");
        for (int i=0; i < oldHops.length; i++) {
            CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
            String[] componentList = oldHops[i].getLinkIdRef().split(":");
            // if local domain
            if (!componentList[3].equals("other")) {
                Link link = domainDAO.getFullyQualifiedLink(componentList);
                hostName = link.getPort().getNode().getTopologyIdent();
                ipaddr = link.getValidIpaddr();
                if (ipaddr == null) {
                    hopId = "*out-of-date IP*";
                } else {
                    hopId = hostName + ": " + ipaddr.getIP();
                }
            } else {
                // this component is IP address in other domain
                String ip = componentList[6];
                hostName = null;
                try {
                    InetAddress inetAddress = InetAddress.getByName(ip);
                    hostName = inetAddress.getHostName();
                } catch (UnknownHostException e) {
                    ;  // non-fatal error
                }
                if ((hostName != null) && !hostName.equals(ip)) {
                    hopId = hostName + ": " + ip;
                } else {
                    hopId = ip;
                }
            }
            hop.setId(hopId);
            hop.setLinkIdRef(hopId);
            newPath.addHop(hop);
        }
        newPath.setId("unimplemented");
        pathInfo.setPath(newPath);
        log.debug("clientConvert.end");
        return;
    }

    /**
     * Given a PathInfo instance, determines whether it contains information
     *     requiring special authorization to set.
     *
     * @param pathInfo a PathInfo instance
     * @return boolean indicating whether contains series of hops
     */
    public static boolean checkPathAuth(PathInfo pathInfo) {

        if (pathInfo.getLayer3Info() != null) {
            CtrlPlanePathContent path = pathInfo.getPath();
            if (path != null) { return true; }
        }
        return false;
    }

    /**
     * Converts a string to a bit mask. The range should take the form
     * "x,y" for discontinuous ranges and "x-y" for continuous ranges.
     * These formats can be concatenated to specify many subranges
     * (i.e 600,3000-3001).
     *
     * @param range the range string to be converted
     * @return a bit mask with values in given range set to 1
     * @throws BSSException
     */
    public static byte[] rangeStringToMask(String range) throws BSSException{
        byte[] mask = new byte[512];

        if (range.trim().equals("any")) {
            for (int i = 0; i < 512; i++) {
                mask[i] = (byte) 255;
            }
            return mask;
        }

        range = range.replaceAll("\\s", "");
        String[] rangeList = range.split(",");
        try {

            for(int i = 0; i < rangeList.length; i++){
                String[] rangeEnds = rangeList[i].split("-");
                if (rangeEnds.length == 1){
                    int tag = Integer.parseInt(rangeEnds[0].trim());
                    if(tag < 4096){
                        mask[tag/8] = (byte)(1 << (7 - (tag % 8)));
                    }
                } else if(rangeEnds.length == 2 && "".equals(rangeEnds[0])){
                    int tag = Integer.parseInt(rangeEnds[1].trim());
                    if(tag < 4096){
                        mask[tag/8] = (byte)(1 << (7 - (tag % 8)));
                    }
                } else if(rangeEnds.length == 2){
                    int startTag = Integer.parseInt(rangeEnds[0].trim());
                    int endTag = Integer.parseInt(rangeEnds[1].trim());
                    if (startTag < 4096 && endTag < 4096){
                        for(int j = startTag; j <= endTag; j++){
                            mask[j/8] |= (1 << (7 - (j % 8)));
                        }
                    }
                }else {
                    throw new BSSException("Invalid VLAN range specified");
                }
            }
        } catch (NumberFormatException ex) {
            throw new BSSException("Invalid VLAN range format	\n"+ ex.getMessage());
        }

        /* for(int k = 0; k < mask.length; k++){
            System.out.println(k + ": " + (byte)(mask[k] & 255));
        } */

        return mask;
    }

    /**
     * Converts given mask to a range string. The range takes the form
     * "x,y" for discontinuous ranges and "x-y" for continuous ranges.
     * These formats can be concatenated to specify many subranges
     * (i.e 600,3000-3001).
     *
     * @param mask the bit mask to be converted
     * @return a range string representing the given bit mask
     */
    public static String maskToRangeString(byte[] mask){
        int start = -2;//far away from 0
        String range = new String();
        boolean allowsAny = true;

        for(int i = 0; i < mask.length; i++){
            for(int j = 0; j < 8; j++){
                int tag = i*8 + j;
                if((mask[i] & (int)Math.pow(2, (7-j))) > 0){
                    if(start == -2){
                        start = tag;
                    }
                }else if(start != -2){
                    allowsAny = false;
                    if(!range.equals("")){
                        range += ",";
                    }
                    range += start;
                    if(start != (tag -1)){
                        range += "-" + (tag-1);
                    }
                    start = -2;
                }
            }
        }
        if (allowsAny) {
            return "0-4096";
        }

        return range;
    }

    /**
     * If given an int whose string length is less than 2, prepends a "0".
     *
     * @param dint int, for example representing month or day
     * @return fixedLength fixed length string of length 2
     */
    private static String fixedLengthTime(int dint) {
        String fixedLength = null;

        if (dint < 10) { fixedLength = "0" + dint; }
        else { fixedLength = "" + dint; }
        return fixedLength;
    }

    /**
     * Converts Reservation Hibernate bean to a HashMap
     *
     * @param resv the Reservation to convert
     * @param pathInfo the pathInfo to use in place of the resv path if provided
     * @return the converted HashMap
     */
    public static HashMap<String, String[]> reservationToHashMap(Reservation resv, PathInfo pathInfo)
    		throws BSSException {
        HashMap<String, String[]> map = new HashMap<String, String[]>();
        if(resv == null){
            return map;
        }

        map.put("startSeconds", genHashVal(resv.getStartTime() + ""));
        map.put("endSeconds", genHashVal(resv.getEndTime() + ""));
        map.put("createSeconds", genHashVal(resv.getCreatedTime() + ""));
        map.put("bandwidth", genHashVal(resv.getBandwidth() + ""));
        map.put("status", genHashVal(resv.getStatus()));
        map.put("description", genHashVal(resv.getDescription()));
        map.put("gri", genHashVal(resv.getGlobalReservationId()));
        map.put("userLogin", genHashVal(resv.getLogin()));

        //set Token
        Token token = resv.getToken();
        if (token != null) {
            map.put("token", genHashVal(token.getValue()));
        }
        //set path
        map.putAll(pathToHashMap(resv.getPath(PathType.INTRADOMAIN), pathInfo));
        return map;
    }

    /**
     * Converts HashMap to a Reservation Hibernate bean
     *
     * @param map a HashMap with parameters to initialize reservation
     * @return resv the converted Reservation
     */
    public static Reservation hashMapToReservation(HashMap<String, String[]> map){
        Reservation resv = new Reservation();
        if (map == null) {
            return resv;
        }
        resv.setStartTime(Long.parseLong(map.get("startSeconds")[0]));
        resv.setEndTime(Long.parseLong(map.get("endSeconds")[0]));
        resv.setCreatedTime(Long.parseLong(map.get("createSeconds")[0]));
        resv.setBandwidth(Long.parseLong(map.get("bandwidth")[0]));
        resv.setDescription(map.get("description")[0]);
        resv.setGlobalReservationId(map.get("gri")[0]);
        resv.setLogin(map.get("userLogin")[0]);

        //TODO: Fill-in pathInfo
        return resv;
    }

    /**
     * Converts Path Hibernate bean to a HashMap
     *
     * @param path the Path to convert
     * @param pathInfo associated path information to add to the hash map
     * @return map the converted HashMap
     */
    public static HashMap<String, String[]> pathToHashMap(Path path, PathInfo pathInfo){
        HashMap<String, String[]> map = new HashMap<String, String[]>();
        ArrayList<String> layers = new ArrayList<String>();
        if(path == null){
            return map;
        }

        Domain nextDomain = path.getNextDomain();
        Layer2Data layer2Data = path.getLayer2Data();
        Layer3Data layer3Data = path.getLayer3Data();
        MPLSData mplsData = path.getMplsData();
        List<PathElem> pathElems = path.getPathElems();
        //PathElem interPathElem = path.getInterPathElem();
        ArrayList<String> intraPath = new ArrayList<String>();
        ArrayList<String> interPath = new ArrayList<String>();
        String src = null;
        String dest = null;

        map.put("isExplicitPath", genHashVal(path.isExplicit() ? "true" : "false"));
        map.put("pathSetupMode", genHashVal(path.getPathSetupMode()));

        if(nextDomain != null){
            map.put("nextDomain", genHashVal(nextDomain.getTopologyIdent()));
        }

        if(layer3Data != null){
            src = layer3Data.getSrcHost();
            dest = layer3Data.getDestHost();
            map.put("source", genHashVal(src));
            map.put("destination", genHashVal(dest));
            //these are in the TCP/UDP headers, not IP headers, hence L4
            map.put("srcPort", genHashVal(layer3Data.getSrcIpPort() + ""));
            map.put("destPort", genHashVal(layer3Data.getDestIpPort() + ""));
            map.put("protocol", genHashVal(layer3Data.getProtocol()));
            map.put("dscp", genHashVal(layer3Data.getDscp()));
            map.put("layer", genHashVal("3"));
            layers.add("3");
        }

        if(layer2Data != null){
            src = layer2Data.getSrcEndpoint();
            dest = layer2Data.getDestEndpoint();
            map.put("source", genHashVal(src));
            map.put("destination", genHashVal(dest));
            layers.add("2");
        }

        map.put("layer", layers.toArray(new String[layers.size()]));

        if(mplsData != null){
            map.put("burstLimit", genHashVal(mplsData.getBurstLimit() + ""));
            map.put("lspClass", genHashVal(mplsData.getLspClass()));
        }


        if(pathInfo != null){
            String pathType = pathInfo.getPathType() == null ? "strict" : pathInfo.getPathType();
            map.put("pathType", genHashVal(pathType));
        }

        /* If given pathInfo add info to hash map*/
        Layer2Info l2Info = null;
        boolean usePathInfo = false;
        ArrayList<String> interHopInfo = new ArrayList<String>();
        if(pathInfo != null && pathInfo.getPath() != null
           && pathInfo.getPath().getHop() != null){
            for(CtrlPlaneHopContent hop :  pathInfo.getPath().getHop()){
                String urn = hopToURN(hop);
                interPath.add(urn);
                CtrlPlaneLinkContent link = hop.getLink();
                if(link != null){
                    String infoVal = link.getTrafficEngineeringMetric();
                    CtrlPlaneSwcapContent swcap = link.getSwitchingCapabilityDescriptors();
                    CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo =
                        swcap.getSwitchingCapabilitySpecificInfo();
                    infoVal += ";" + swcap.getSwitchingcapType();
                    infoVal += ";" + swcap.getEncodingType();
                    if(swcap.getSwitchingcapType().equals("l2sc")){
                        infoVal += ";" + swcapInfo.getInterfaceMTU();
                        infoVal += ";" + swcapInfo.getVlanRangeAvailability();
                        infoVal += ";" + swcapInfo.getSuggestedVLANRange();
                    }else{
                        infoVal += ";" + swcapInfo.getCapability();
                    }
                    interHopInfo.add(infoVal);
                }else{
                    interHopInfo.add("");
                }
            }
            l2Info = pathInfo.getLayer2Info();
            usePathInfo = true;
        }
        if (!usePathInfo) {
            // INTERDOMAIN
            /*
            for (PathElem pathElem: interPathElems) {
                Link link = interPathElem.getLink();
                if(link != null){
                    String linkId = link.getFQTI();
                    interPath.add(linkId);
                    interHopInfo.add(this.getPathElemInfo(interPathElem));
                    map.putAll(this.vlanToHashMap(interPathElem, src, dest, layer2Data));
                }else{
                    this.log.error("Could not locate a link for interPathElem, id: "+interPathElem.getId());
                }
            }
            */
        } else if (l2Info != null) {
            if (l2Info.getSrcVtag() != null) {
                map.put("srcVtag", genHashVal(l2Info.getSrcVtag().getString()));
                map.put("tagSrcPort", genHashVal(l2Info.getSrcVtag().getTagged() + ""));
            }
            if (l2Info.getDestVtag() != null) {
                map.put("destVtag", genHashVal(l2Info.getSrcVtag().getString()));
                map.put("tagDestPort", genHashVal(l2Info.getDestVtag().getTagged() + ""));
            }
        }
        map.put("interdomainPath", interPath.toArray(new String[interPath.size()]));
        map.put("interdomainHopInfo", interHopInfo.toArray(new String[interHopInfo.size()]));

        ArrayList<String> intraHopInfo = new ArrayList<String>();
        for (PathElem pathElem: pathElems) {
            Link link = pathElem.getLink();
            if (link != null) {
                String linkId = link.getFQTI();
                intraPath.add(linkId);
                intraHopInfo.add(getPathElemInfo(pathElem));
                map.putAll(vlanToHashMap(pathElem, src, dest, layer2Data));
            } else {
                log.error("Could not locate a link for pathElem, id: "+pathElem.getId());
            }
        }
        map.put("intradomainPath", intraPath.toArray(new String[intraPath.size()]));
        map.put("intradomainHopInfo", intraHopInfo.toArray(new String[intraHopInfo.size()]));

        return map;
    }

    /**
     * Creates a ';' delimited String with detailed information about each hop
     * in a path.
     *
     * @param pathElem the pathElem for which to generate information
     * @return a ';' delimited String with detailed information about each hop
     */
     private static String getPathElemInfo(PathElem pathElem){
        Link link = pathElem.getLink();
        L2SwitchingCapabilityData l2scData = link.getL2SwitchingCapabilityData();
        String infoVal = link.getTrafficEngineeringMetric();
        String defaulSwcapType = PathManager.DEFAULT_SWCAP_TYPE;
        String defaulEncType = PathManager.DEFAULT_ENC_TYPE;
        if(l2scData != null){
            //TEMetric;swcap;enc;MTU;VLANRangeAvail;SuggestedVLANRange
            infoVal += ";l2sc;ethernet";
            infoVal += ";" + l2scData.getInterfaceMTU();
            infoVal += ";" + pathElem.getLinkDescr();
            infoVal += ";null";
        }else{
            //TEMetric;swcap;enc;MTU;capbility
            infoVal += ";" + defaulSwcapType + ";" + defaulEncType + ";unimplemented";
        }

        return infoVal;
     }

    /**
     * Converts PathElem Hibernate bean of a layer2 link to a HashMap
     *
     * @param elem the PathElem to convert
     * @param src the source URN of the reservation
     * @param dest the destination URN of the reservation
     * @param layer2Data the layer 2 data associated with a reservation
     * @return the converted HashMap
     */
    private static HashMap<String, String[]> vlanToHashMap(PathElem elem, String src,
                                                    String dest,
                                                    Layer2Data layer2Data){
        HashMap<String, String[]> map = new HashMap<String, String[]>();
        if(layer2Data == null){
            return map;
        }

        String linkId = elem.getLink().getFQTI();
        String descr = elem.getDescription();
        String tagField = "";
        if(linkId.equals(src)){
            tagField = "tagSrcPort";
            try{
                int vtag = Integer.parseInt(descr);
                map.put(tagField, genHashVal(vtag > 0 ? "true" : "false"));
                map.put("srcVtag", genHashVal(descr));
            }catch(Exception e){}
        }else if(linkId.equals(dest)){
            tagField = "tagDestPort";
            try{
                int vtag = Integer.parseInt(descr);
                map.put(tagField, genHashVal(vtag > 0 ? "true" : "false"));
                map.put("destVtag", genHashVal(descr));
            }catch(Exception e){}
        }

        return map;
    }

    /**
     * Generates a String array from a String
     *
     * @param value the String to convert
     * @return the converted array
     */
    private static String[] genHashVal(String value){
        if(value == null){
            return null;
        }
        String[] array = new String[1];
        array[0] = value;
        return array;
    }

    /**
     * Extracts a String from a String array
     *
     * @param array the String[] to extract
     * @return the converted array
     */
    private static String extractHashVal(String[] array){
        if(array == null || array.length < 1){
            return null;
        }
        return array[0];
    }

    /**
     * Extracts a long from a String array
     *
     * @param array the String[] to extract
     * @return the converted array
     */
    private static long extractHashLongVal(String[] array){
        long longVal = 0;
        if(array == null || array.length < 1){
            return 0;
        }
        try{
            longVal = Long.parseLong(array[0]);
        }catch(Exception e){}

        return longVal;
    }

    /**
     * Extracts a int from a String array
     *
     * @param array the String[] to extract
     * @return the converted array
     */
    private static int extractHashIntVal(String[] array){
        int intVal = 0;
        if(array == null || array.length < 1){
            return 0;
        }
        try{
            intVal = Integer.parseInt(array[0]);
        }catch(Exception e){}

        return intVal;
    }

    /**
     * Converts a hash map to a ResDetail object for Axis2
     *
     * @param map a HashMap with reservation information
     * @return the converted HashMap in a ResDetails object
     */
    public static ResDetails hashMaptoResDetails(HashMap<String, String[]> map){
        //Verify that map has enough fields to build valid ResDetails object
        final String[] requiredFields = { "gri", "userLogin", "status",
                                          "startSeconds", "endSeconds",
                                          "createSeconds", "bandwidth",
                                          "description", "pathSetupMode" };
        if(map == null){ return null; }
        for(int i = 0; i < requiredFields.length; i++){
            if(map.get(requiredFields[i]) == null){
                return null;
            }
        }

        //If everything looks good then build the object
        ResDetails details = new ResDetails();
        PathInfo pathInfo = new PathInfo();
        boolean hasLayer2Params = false;
        boolean hasLayer3Params = false;
        details.setGlobalReservationId(extractHashVal(map.get("gri")));
        details.setLogin(extractHashVal(map.get("userLogin")));
        details.setStatus(extractHashVal(map.get("status")));
        details.setStartTime(extractHashLongVal(map.get("startSeconds")));
        details.setEndTime(extractHashLongVal(map.get("endSeconds")));
        details.setCreateTime(extractHashLongVal(map.get("createTime")));
        details.setBandwidth(extractHashIntVal(map.get("bandwidth")));
        details.setDescription(extractHashVal(map.get("description")));

        pathInfo.setPathSetupMode(extractHashVal(map.get("pathSetupMode")));
        pathInfo.setPathType(extractHashVal(map.get("pathType")));

        /*Set Path
           use interdomain path if available otherwise just use the
           intradomain path. If this will be used in an idc:event
           object then the intradomain path will also be included in
           /idc:event/idc:localDetails */
        String[] path = map.get("interdomainPath");
        String[] hopInfo = map.get("interdomainHopInfo");
        String[] intra = map.get("intradomainPath");
        String[] intraHopInfo = map.get("intradomainHopInfo");
        //if no interdomain path show the local ingress/egress
        /* TODO: Conversion from intradomain to interdomain should be done
            in domain-specific module like Pathfinder */
        if(path == null && intra != null && intra.length == 1){
            path = intra;
            hopInfo = intraHopInfo;
        }else if(path == null && intra != null && intra.length > 1){
            path = new String[2];
            path[0] = intra[0];
            path[1] = intra[intra.length-1];
            hopInfo[0] = intraHopInfo[0];
            hopInfo[1] = intraHopInfo[intraHopInfo.length-1];
        }
        if(path != null){
            CtrlPlanePathContent wsPath = arrayToCtrlPlanePath(path, hopInfo);
            pathInfo.setPath(wsPath);
        }

        //Get layers
        String[] layers = map.get("layer");
        for(int i = 0; layers!= null && i < layers.length; i++){
            if("2".equals(layers[i])){
                hasLayer2Params = true;
            }else if("3".equals(layers[i])){
                hasLayer3Params = true;
            }
        }

        if(hasLayer2Params){
            Layer2Info layer2Info = new Layer2Info();
            String srcVtagStr = extractHashVal(map.get("srcVtag"));
            String destVtagStr = extractHashVal(map.get("destVtag"));
            layer2Info.setSrcEndpoint(extractHashVal(map.get("source")));
            layer2Info.setDestEndpoint(extractHashVal(map.get("destination")));
            if(srcVtagStr != null){
                VlanTag vtag = new VlanTag();
                String isTagged = extractHashVal(map.get("tagSrcPort"));
                vtag.setString(srcVtagStr);
                vtag.setTagged(isTagged!= null && "true".equals(isTagged));
                layer2Info.setSrcVtag(vtag);
            }
            if(destVtagStr != null){
                VlanTag vtag = new VlanTag();
                String isTagged = extractHashVal(map.get("tagDestPort"));
                vtag.setString(destVtagStr);
                vtag.setTagged(isTagged!= null && "true".equals(isTagged));
                layer2Info.setDestVtag(vtag);
            }
            pathInfo.setLayer2Info(layer2Info);
        }

        if(hasLayer3Params){
            Layer3Info layer3Info = new Layer3Info();
            layer3Info.setSrcHost(extractHashVal(map.get("source")));
            layer3Info.setDestHost(extractHashVal(map.get("destination")));
            layer3Info.setProtocol(extractHashVal(map.get("protocol")));
            layer3Info.setSrcIpPort(extractHashIntVal(map.get("srcPort")));
            layer3Info.setDestIpPort(extractHashIntVal(map.get("destPort")));
            layer3Info.setDscp(extractHashVal(map.get("dscp")));
            pathInfo.setLayer3Info(layer3Info);
        }

        int burstLimit = extractHashIntVal(map.get("burstLimit"));
        String lspClass = extractHashVal(map.get("lspClass"));
        if(burstLimit != 0 || lspClass != null){
            MplsInfo mplsInfo = new MplsInfo();
            mplsInfo.setLspClass(lspClass);
            mplsInfo.setBurstLimit(burstLimit);
            pathInfo.setMplsInfo(mplsInfo);
        }

        details.setPathInfo(pathInfo);

        return details;
    }

    /**
     * Converts a string array of a path and its corresponding array of hop
     * details to a CtrlPlanePathContent object.
     *
     * @param path the path to convert as an array of URNs
     * @param hopInfo the details of each hop in the path
     * @return the converted CtrlPlanePathContent
     */
     public static CtrlPlanePathContent arrayToCtrlPlanePath(String[] path, String[] hopInfo){
        CtrlPlanePathContent wsPath = new CtrlPlanePathContent();
        wsPath.setId("resvPath");
        for(int i = 0; i < path.length; i++){
            CtrlPlaneHopContent hop = new CtrlPlaneHopContent();
            hop.setId((i+1) + "");
            Hashtable<String, String> parseResults = URNParser.parseTopoIdent(path[i]);
            String hopType = parseResults.get("type");
            if("link".equals(hopType) && "".equals(hopInfo[i])){
                hop.setLinkIdRef(path[i]);
            }else if("link".equals(hopType)){
                CtrlPlaneLinkContent link = new CtrlPlaneLinkContent();
                link.setId(path[i]);
                String[] infoVals = hopInfo[i].split(";");
                link.setTrafficEngineeringMetric(infoVals[0] + "");
                CtrlPlaneSwcapContent linkSwcap = new CtrlPlaneSwcapContent();
                linkSwcap.setSwitchingcapType(infoVals[1]);
                linkSwcap.setEncodingType(infoVals[2]);
                CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo = new CtrlPlaneSwitchingCapabilitySpecificInfo();
                if("l2sc".equals(infoVals[1])){
                    swcapInfo.setInterfaceMTU("null".equals(infoVals[3]) ? 0 : Integer.parseInt(infoVals[3]));
                    swcapInfo.setVlanRangeAvailability("null".equals(infoVals[4]) ? null : infoVals[4]);
                    swcapInfo.setSuggestedVLANRange("null".equals(infoVals[5]) ? null : infoVals[5]);
                }else{
                   swcapInfo.setCapability("null".equals(infoVals[3]) ? null : infoVals[3]);
                }
                linkSwcap.setSwitchingCapabilitySpecificInfo(swcapInfo);
                link.setSwitchingCapabilityDescriptors(linkSwcap);
                hop.setLink(link);
            }else if("port".equals(hopType)){
                /* we don't define how port, node, and domain objects are used
                   in path yet so just use idrefs */
                hop.setPortIdRef(path[i]);
            }else if("node".equals(hopType)){
                hop.setNodeIdRef(path[i]);
            }else if("domain".equals(hopType)){
                hop.setDomainIdRef(path[i]);
            }

            wsPath.addHop(hop);
        }
        return wsPath;
     }

    /**
     * Converts Axis2 Layer2Info object to a Layer2Data Hibernate bean
     *
     * @param layer2Info the Layer2Info object to convert
     * @return the converted Layer2Data bean
     */
     public static Layer2Data layer2InfoToData(Layer2Info layer2Info){
        if(layer2Info == null){
            return null;
        }
        Layer2Data layer2Data = new Layer2Data();
        layer2Data.setSrcEndpoint(layer2Info.getSrcEndpoint());
        layer2Data.setDestEndpoint(layer2Info.getDestEndpoint());

        return layer2Data;
     }

     /**
     * Converts Axis2 Layer3Info object to a Layer3Data Hibernate bean
     *
     * @param layer3Info the Layer3Info object to convert
     * @return the converted Layer3Data bean
     */
     public static Layer3Data layer3InfoToData(Layer3Info layer3Info){
        if(layer3Info == null){
            return null;
        }
        Layer3Data layer3Data = new Layer3Data();

        layer3Data.setSrcHost(layer3Info.getSrcHost());
        layer3Data.setDestHost(layer3Info.getDestHost());
        layer3Data.setSrcIpPort(layer3Info.getSrcIpPort());
        layer3Data.setDestIpPort(layer3Info.getDestIpPort());
        layer3Data.setProtocol(layer3Info.getProtocol());
        layer3Data.setDscp(layer3Info.getDscp());

        return layer3Data;
     }

     /**
     * Converts Axis2 MplsInfo object to a MPLSData Hibernate bean
     *
     * @param mplsInfo the MplsInfo object to convert
     * @return the converted MPLSData bean
     */
     public static MPLSData mplsInfoToData(MplsInfo mplsInfo){
        if(mplsInfo == null){
            return null;
        }
        MPLSData mplsData = new MPLSData();

        mplsData.setBurstLimit((long) mplsInfo.getBurstLimit());
        mplsData.setLspClass(mplsInfo.getLspClass());

        return mplsData;
     }

     /**
     * Returns the URN of the any type based on the hop object ID or
     * IDRef field. Also does some validation Axis2 is missing.
     *
     * @param hop the CtrlPlaneHopContent to parse
     * @return the domain,node,port or link URN of the hop, null if invalid hop
     */
    public static String hopToURN(CtrlPlaneHopContent hop){
        return hopToURN(hop, "any");
    }

     /**
     * Returns the URN of the given type based on the hop object ID or
     * IDRef field. Also does some validation Axis2 is missing.
     *
     * @param hop the CtrlPlaneHopContent to parse
     * @param type string with type of hop
     * @return the domain,node,port or link URN of the hop, null if invalid hop
     */
    public static String hopToURN(CtrlPlaneHopContent hop, String type){
        if(hop == null){
            return null;
        }
        if(type == null || !("link".equals(type) || "any".equals(type) ||
           "port".equals(type) || "node".equals(type) || "domain".equals(type))){
            return null;
        }
        String urn = null;
        int urnType = 0;
        int childCount = 0;

        String linkIdRef = hop.getLinkIdRef();
        if(linkIdRef != null){
            urn = linkIdRef;
            urnType = 1;
            childCount++;
        }
        CtrlPlaneLinkContent link = hop.getLink();
        if(link != null){
            urn = link.getId();
            urnType = 1;
            childCount++;
        }
        if("link".equals(type)){
            return urn;
        }

        String portIdRef = hop.getPortIdRef();
        if(portIdRef != null){
            urn = portIdRef;
            urnType = 2;
            childCount++;
        }
        CtrlPlanePortContent port = hop.getPort();
        if(port != null){
            urn = port.getId();
            urnType = 2;
            childCount++;
        }
        if("port".equals(type) && urnType == 2){
            return urn;
        }else if(urnType == 2){
            return null;
        }

        String nodeIdRef = hop.getNodeIdRef();
        if(nodeIdRef != null){
            urn = nodeIdRef;
            urnType = 3;
            childCount++;
        }
        CtrlPlaneNodeContent node = hop.getNode();
        if(node != null){
            urn = node.getId();
            urnType = 3;
            childCount++;
        }
        if("node".equals(type) && urnType == 3){
            return urn;
        }else if(urnType == 3){
            return null;
        }

        String domainIdRef = hop.getDomainIdRef();
        if(domainIdRef != null){
            urn = domainIdRef;
            urnType = 4;
            childCount++;
        }
        CtrlPlaneDomainContent domain = hop.getDomain();
        if(domain != null){
            urn = domain.getId();
            urnType = 4;
            childCount++;
        }
        if("domain".equals(type) && urnType == 4){
            return urn;
        }else if(urnType == 4){
            return null;
        }

        /* we have to tcheck errors ourselves because xsd:choice
          elements are clunky in Axis2 */
        if(urn == null){
            log.debug("Empty hop");
        }else if(childCount > 1){
            log.debug("Parse error: Hop must contain only one " +
                           "domain, node, port or link object/reference");
            urn = null;
        }

        return urn;
    }

    /**
     * Converts a path in a PathInfo object that may contain a mixture of
     * references and objects and converts it to a path containing only references.
     * It then returns a new copy of the PathInfo object containing the converted
     * path.
     *
     * @param pathInfo the pathInfo with the CtrlPlanePathContent to convert
     * @return the a new pathInfo object with the converted path
     */
     public static PathInfo createRefPath(PathInfo pathInfo){
        CtrlPlanePathContent path = pathInfo.getPath();
        CtrlPlanePathContent refPath = new CtrlPlanePathContent();
        if(path == null){
            return pathInfo;
        }
        CtrlPlaneHopContent[] hops = path.getHop();
        if(hops == null || hops.length < 1){
            return pathInfo;
        }
        /* Create a copy so that the path in the original PathInfo
           remains the same. */
        PathInfo refPathInfo = new PathInfo();
        refPathInfo.setPathSetupMode(pathInfo.getPathSetupMode());
        refPathInfo.setPathType(pathInfo.getPathType());
        refPathInfo.setLayer2Info(pathInfo.getLayer2Info());
        refPathInfo.setLayer3Info(pathInfo.getLayer3Info());
        refPathInfo.setMplsInfo(pathInfo.getMplsInfo());

        refPath.setId(path.getId());
        for(CtrlPlaneHopContent hop : hops){
            String urn = hopToURN(hop);
            CtrlPlaneHopContent refHop = new CtrlPlaneHopContent();
            refHop.setId(hop.getId());
            if(urn == null){
                //if invalid hop just skip it
                log.debug("createRefPath=skipping invalid hop");
                continue;
            }
            int parts = urn.split(":").length;
            if(parts == 7){
                refHop.setLinkIdRef(urn);
            }else if(parts == 6){
                refHop.setPortIdRef(urn);
            }else if(parts == 5){
                refHop.setNodeIdRef(urn);
            }else if(parts == 4){
                refHop.setDomainIdRef(urn);
            }else{
                log.debug("createRefPath=skipping invalid urn");
                continue;
            }
            refPath.addHop(refHop);
        }
        refPathInfo.setPath(refPath);

        return refPathInfo;
     }

     /**
      * Merge additional hops in the new path with an original path while maintaining any
      * objects in that path. Useful for pathfinders that only work on paths containing
      * IDRefs.
      *
      * @param origPathInfo the original path that may have objects to maintain
      * @param newPathInfo the new path the may only contain references
      * @param saveToNew if true writes merged path to newPathInfo, otherwise writes to origPathInfo
      */
      public static void mergePathInfo(PathInfo origPathInfo, PathInfo newPathInfo, boolean saveToNew) throws BSSException{
        CtrlPlanePathContent mergedPath = new CtrlPlanePathContent();
        int i = 0;
        int j = 0;
        CtrlPlanePathContent origPath = origPathInfo.getPath();
        CtrlPlanePathContent newPath = newPathInfo.getPath();
        HashMap<String, CtrlPlaneHopContent> hopMap = new  HashMap<String, CtrlPlaneHopContent>();
        if(newPath == null || newPath.getHop() == null ||
           newPath.getHop().length == 0){
            return;
        }else if(origPath == null || origPath.getHop() == null){
            origPath = new CtrlPlanePathContent();
            origPath.setHop(new CtrlPlaneHopContent[0]);
        }

        CtrlPlaneHopContent[] origHops = origPath.getHop();
        CtrlPlaneHopContent[] newHops = newPath.getHop();
        for(CtrlPlaneHopContent origHop : origHops){
            String urn = hopToURN(origHop);
            hopMap.put(urn, origHop);
        }
        for(CtrlPlaneHopContent newHop : newHops){
            String urn = hopToURN(newHop);
            if(hopMap.containsKey(urn)){
                mergedPath.addHop(hopMap.get(urn));
            }else{
                mergedPath.addHop(newHop);
            }
        }
        if(saveToNew){
            newPathInfo.setPath(mergedPath);
        }else{
            origPathInfo.setPathType(newPathInfo.getPathType());
            origPathInfo.setPath(mergedPath);
        }
      }

}
