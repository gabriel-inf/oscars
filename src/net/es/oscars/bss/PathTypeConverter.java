/**
 * Performs and supports conversion operations on Hibernate Paths.
 *
 * @author Andrew Lake, David Robertson
 */
package net.es.oscars.bss;

import java.util.*;

import org.apache.log4j.*;

import net.es.oscars.bss.Reservation;
import net.es.oscars.bss.Token;
import net.es.oscars.bss.PathManager;
import net.es.oscars.bss.BSSException;
import net.es.oscars.bss.topology.*;
// TODO:  to remove
import net.es.oscars.oscars.TypeConverter;
import net.es.oscars.wsdlTypes.*;
// code generated by Martin Swany's schemas
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneDomainContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneHopContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneLinkContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneNodeContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePathContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlanePortContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwcapContent;
import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneSwitchingCapabilitySpecificInfo;
// end to remove


/**
 * Has methods to perform and support conversion operations on Paths.
 * Any conversions involving the Axis2 PathInfo structure are performed
 * in oscars.TypeConverter.
 */
public class PathTypeConverter {

    private static Logger log = Logger.getLogger(TypeConverter.class);

    // do not instantiate
    private PathTypeConverter() {
    }

    /**
     * Converts Reservation Hibernate bean to a HashMap
     *
     * @param resv the Reservation to convert
     * @return the converted HashMap
     */
    public static HashMap<String, String[]>
        reservationToHashMap(Reservation resv)
    		    throws BSSException {

        HashMap<String, String[]> map = new HashMap<String, String[]>();
        if(resv == null){
            return map;
        }

        map.put("startSeconds", genHashVal(resv.getStartTime() + ""));
        map.put("endSeconds", genHashVal(resv.getEndTime() + ""));
        map.put("createSeconds", genHashVal(resv.getCreatedTime() + ""));
        map.put("bandwidth", genHashVal(resv.getBandwidth() + ""));
        map.put("status", genHashVal(resv.getStatus()));
        map.put("description", genHashVal(resv.getDescription()));
        map.put("gri", genHashVal(resv.getGlobalReservationId()));
        map.put("userLogin", genHashVal(resv.getLogin()));

        //set Token
        Token token = resv.getToken();
        if (token != null) {
            map.put("token", genHashVal(token.getValue()));
        }
        //set local path
        // FIXME
        // map.putAll(pathToHashMap(resv.getPath(PathType.LOCAL)));
        // set interdomain path
        // map.putAll(pathToHashMap(resv.getPath(PathType.INTERDOMAIN)));
        return map;
    }

    /**
     * Converts HashMap to a Reservation Hibernate bean
     *
     * @param map a HashMap with parameters to initialize reservation
     * @return resv the converted Reservation
     */
    public static Reservation hashMapToReservation(HashMap<String, String[]> map){
        Reservation resv = new Reservation();
        if (map == null) {
            return resv;
        }
        resv.setStartTime(Long.parseLong(map.get("startSeconds")[0]));
        resv.setEndTime(Long.parseLong(map.get("endSeconds")[0]));
        resv.setCreatedTime(Long.parseLong(map.get("createSeconds")[0]));
        resv.setBandwidth(Long.parseLong(map.get("bandwidth")[0]));
        resv.setDescription(map.get("description")[0]);
        resv.setGlobalReservationId(map.get("gri")[0]);
        resv.setLogin(map.get("userLogin")[0]);

        //TODO: Fill-in path
        return resv;
    }

    /**
     * Converts Path Hibernate bean to a HashMap
     *
     * @param path the Path to convert
     * @param pathInfo associated path information to add to the hash map
     * @return map the converted HashMap
     */
    public static HashMap<String, String[]> pathToHashMap(Path path, PathInfo pathInfo){
        HashMap<String, String[]> map = new HashMap<String, String[]>();
        ArrayList<String> layers = new ArrayList<String>();
        if(path == null){
            return map;
        }

        Domain nextDomain = path.getNextDomain();
        Layer2Data layer2Data = path.getLayer2Data();
        Layer3Data layer3Data = path.getLayer3Data();
        MPLSData mplsData = path.getMplsData();
        List<PathElem> pathElems = path.getPathElems();
        //PathElem interPathElem = path.getInterPathElem();
        ArrayList<String> intraPath = new ArrayList<String>();
        ArrayList<String> interPath = new ArrayList<String>();
        String src = null;
        String dest = null;

        map.put("isExplicitPath", genHashVal(path.isExplicit() ? "true" : "false"));
        map.put("pathSetupMode", genHashVal(path.getPathSetupMode()));

        if(nextDomain != null){
            map.put("nextDomain", genHashVal(nextDomain.getTopologyIdent()));
        }

        if(layer3Data != null){
            src = layer3Data.getSrcHost();
            dest = layer3Data.getDestHost();
            map.put("source", genHashVal(src));
            map.put("destination", genHashVal(dest));
            //these are in the TCP/UDP headers, not IP headers, hence L4
            map.put("srcPort", genHashVal(layer3Data.getSrcIpPort() + ""));
            map.put("destPort", genHashVal(layer3Data.getDestIpPort() + ""));
            map.put("protocol", genHashVal(layer3Data.getProtocol()));
            map.put("dscp", genHashVal(layer3Data.getDscp()));
            map.put("layer", genHashVal("3"));
            layers.add("3");
        }

        if(layer2Data != null){
            src = layer2Data.getSrcEndpoint();
            dest = layer2Data.getDestEndpoint();
            map.put("source", genHashVal(src));
            map.put("destination", genHashVal(dest));
            layers.add("2");
        }

        map.put("layer", layers.toArray(new String[layers.size()]));

        if(mplsData != null){
            map.put("burstLimit", genHashVal(mplsData.getBurstLimit() + ""));
            map.put("lspClass", genHashVal(mplsData.getLspClass()));
        }


        if(pathInfo != null){
            String pathType = pathInfo.getPathType() == null ? "strict" : pathInfo.getPathType();
            map.put("pathType", genHashVal(pathType));
        }

        /* If given pathInfo add info to hash map*/
        Layer2Info l2Info = null;
        boolean usePathInfo = false;
        ArrayList<String> interHopInfo = new ArrayList<String>();
        if(pathInfo != null && pathInfo.getPath() != null
           && pathInfo.getPath().getHop() != null){
            for(CtrlPlaneHopContent hop :  pathInfo.getPath().getHop()){
                String urn = TypeConverter.hopToURN(hop);
                interPath.add(urn);
                CtrlPlaneLinkContent link = hop.getLink();
                if(link != null){
                    String infoVal = link.getTrafficEngineeringMetric();
                    CtrlPlaneSwcapContent swcap = link.getSwitchingCapabilityDescriptors();
                    CtrlPlaneSwitchingCapabilitySpecificInfo swcapInfo =
                        swcap.getSwitchingCapabilitySpecificInfo();
                    infoVal += ";" + swcap.getSwitchingcapType();
                    infoVal += ";" + swcap.getEncodingType();
                    if(swcap.getSwitchingcapType().equals("l2sc")){
                        infoVal += ";" + swcapInfo.getInterfaceMTU();
                        infoVal += ";" + swcapInfo.getVlanRangeAvailability();
                        infoVal += ";" + swcapInfo.getSuggestedVLANRange();
                    }else{
                        infoVal += ";" + swcapInfo.getCapability();
                    }
                    interHopInfo.add(infoVal);
                }else{
                    interHopInfo.add("");
                }
            }
            l2Info = pathInfo.getLayer2Info();
            usePathInfo = true;
        }
        if (!usePathInfo) {
            // INTERDOMAIN
            /*
            for (PathElem pathElem: interPathElems) {
                Link link = interPathElem.getLink();
                if(link != null){
                    String linkId = link.getFQTI();
                    interPath.add(linkId);
                    interHopInfo.add(this.getPathElemInfo(interPathElem));
                    map.putAll(this.vlanToHashMap(interPathElem, src, dest, layer2Data));
                }else{
                    this.log.error("Could not locate a link for interPathElem, id: "+interPathElem.getId());
                }
            }
            */
        } else if (l2Info != null) {
            if (l2Info.getSrcVtag() != null) {
                map.put("srcVtag", genHashVal(l2Info.getSrcVtag().getString()));
                map.put("tagSrcPort", genHashVal(l2Info.getSrcVtag().getTagged() + ""));
            }
            if (l2Info.getDestVtag() != null) {
                map.put("destVtag", genHashVal(l2Info.getSrcVtag().getString()));
                map.put("tagDestPort", genHashVal(l2Info.getDestVtag().getTagged() + ""));
            }
        }
        map.put("interdomainPath", interPath.toArray(new String[interPath.size()]));
        map.put("interdomainHopInfo", interHopInfo.toArray(new String[interHopInfo.size()]));

        ArrayList<String> intraHopInfo = new ArrayList<String>();
        for (PathElem pathElem: pathElems) {
            Link link = pathElem.getLink();
            if (link != null) {
                String linkId = link.getFQTI();
                intraPath.add(linkId);
                intraHopInfo.add(getPathElemInfo(pathElem));
                map.putAll(vlanToHashMap(pathElem, src, dest, layer2Data));
            } else {
                log.error("Could not locate a link for pathElem, id: "+pathElem.getId());
            }
        }
        map.put("intradomainPath", intraPath.toArray(new String[intraPath.size()]));
        map.put("intradomainHopInfo", intraHopInfo.toArray(new String[intraHopInfo.size()]));

        return map;
    }

    /**
     * Creates a ';' delimited String with detailed information about each hop
     * in a path.
     *
     * @param pathElem the pathElem for which to generate information
     * @return a ';' delimited String with detailed information about each hop
     */
     private static String getPathElemInfo(PathElem pathElem){
        Link link = pathElem.getLink();
        L2SwitchingCapabilityData l2scData = link.getL2SwitchingCapabilityData();
        String infoVal = link.getTrafficEngineeringMetric();
        String defaulSwcapType = PathManager.DEFAULT_SWCAP_TYPE;
        String defaulEncType = PathManager.DEFAULT_ENC_TYPE;
        if(l2scData != null){
            //TEMetric;swcap;enc;MTU;VLANRangeAvail;SuggestedVLANRange
            infoVal += ";l2sc;ethernet";
            infoVal += ";" + l2scData.getInterfaceMTU();
            infoVal += ";" + pathElem.getLinkDescr();
            infoVal += ";null";
        }else{
            //TEMetric;swcap;enc;MTU;capbility
            infoVal += ";" + defaulSwcapType + ";" + defaulEncType + ";unimplemented";
        }

        return infoVal;
     }

    /**
     * Converts PathElem Hibernate bean of a layer2 link to a HashMap
     *
     * @param elem the PathElem to convert
     * @param src the source URN of the reservation
     * @param dest the destination URN of the reservation
     * @param layer2Data the layer 2 data associated with a reservation
     * @return the converted HashMap
     */
    private static HashMap<String, String[]> vlanToHashMap(PathElem elem, String src,
                                                    String dest,
                                                    Layer2Data layer2Data){
        HashMap<String, String[]> map = new HashMap<String, String[]>();
        if(layer2Data == null){
            return map;
        }

        String linkId = elem.getLink().getFQTI();
        String descr = elem.getDescription();
        String tagField = "";
        if(linkId.equals(src)){
            tagField = "tagSrcPort";
            try{
                int vtag = Integer.parseInt(descr);
                map.put(tagField, genHashVal(vtag > 0 ? "true" : "false"));
                map.put("srcVtag", genHashVal(descr));
            }catch(Exception e){}
        }else if(linkId.equals(dest)){
            tagField = "tagDestPort";
            try{
                int vtag = Integer.parseInt(descr);
                map.put(tagField, genHashVal(vtag > 0 ? "true" : "false"));
                map.put("destVtag", genHashVal(descr));
            }catch(Exception e){}
        }

        return map;
    }

    /**
     * Generates a String array from a String
     *
     * @param value the String to convert
     * @return the converted array
     */
    private static String[] genHashVal(String value){
        if(value == null){
            return null;
        }
        String[] array = new String[1];
        array[0] = value;
        return array;
    }

    /**
     * Converts a path in a PathInfo object that may contain a mixture of
     * references and objects and converts it to a path containing only references.
     * It then returns a new copy of the PathInfo object containing the converted
     * path.
     *
     * @param pathInfo the pathInfo with the CtrlPlanePathContent to convert
     * @return the a new pathInfo object with the converted path
     */
     public static PathInfo createRefPath(PathInfo pathInfo){
        CtrlPlanePathContent path = pathInfo.getPath();
        CtrlPlanePathContent refPath = new CtrlPlanePathContent();
        if(path == null){
            return pathInfo;
        }
        CtrlPlaneHopContent[] hops = path.getHop();
        if(hops == null || hops.length < 1){
            return pathInfo;
        }
        /* Create a copy so that the path in the original PathInfo
           remains the same. */
        PathInfo refPathInfo = new PathInfo();
        refPathInfo.setPathSetupMode(pathInfo.getPathSetupMode());
        refPathInfo.setPathType(pathInfo.getPathType());
        refPathInfo.setLayer2Info(pathInfo.getLayer2Info());
        refPathInfo.setLayer3Info(pathInfo.getLayer3Info());
        refPathInfo.setMplsInfo(pathInfo.getMplsInfo());

        refPath.setId(path.getId());
        for(CtrlPlaneHopContent hop : hops){
            String urn = TypeConverter.hopToURN(hop);
            CtrlPlaneHopContent refHop = new CtrlPlaneHopContent();
            refHop.setId(hop.getId());
            if(urn == null){
                //if invalid hop just skip it
                log.debug("createRefPath=skipping invalid hop");
                continue;
            }
            int parts = urn.split(":").length;
            if(parts == 7){
                refHop.setLinkIdRef(urn);
            }else if(parts == 6){
                refHop.setPortIdRef(urn);
            }else if(parts == 5){
                refHop.setNodeIdRef(urn);
            }else if(parts == 4){
                refHop.setDomainIdRef(urn);
            }else{
                log.debug("createRefPath=skipping invalid urn");
                continue;
            }
            refPath.addHop(refHop);
        }
        refPathInfo.setPath(refPath);

        return refPathInfo;
     }

     /**
      * Merge additional hops in the new path with an original path while maintaining any
      * objects in that path. Useful for pathfinders that only work on paths containing
      * IDRefs.
      *
      * @param origPathInfo the original path that may have objects to maintain
      * @param newPathInfo the new path the may only contain references
      * @param saveToNew if true writes merged path to newPathInfo, otherwise writes to origPathInfo
      */
      public static void mergePathInfo(PathInfo origPathInfo, PathInfo newPathInfo, boolean saveToNew) throws BSSException{
        CtrlPlanePathContent mergedPath = new CtrlPlanePathContent();
        int i = 0;
        int j = 0;
        CtrlPlanePathContent origPath = origPathInfo.getPath();
        CtrlPlanePathContent newPath = newPathInfo.getPath();
        HashMap<String, CtrlPlaneHopContent> hopMap = new  HashMap<String, CtrlPlaneHopContent>();
        if(newPath == null || newPath.getHop() == null ||
           newPath.getHop().length == 0){
            return;
        }else if(origPath == null || origPath.getHop() == null){
            origPath = new CtrlPlanePathContent();
            origPath.setHop(new CtrlPlaneHopContent[0]);
        }

        CtrlPlaneHopContent[] origHops = origPath.getHop();
        CtrlPlaneHopContent[] newHops = newPath.getHop();
        for(CtrlPlaneHopContent origHop : origHops){
            String urn = TypeConverter.hopToURN(origHop);
            hopMap.put(urn, origHop);
        }
        for(CtrlPlaneHopContent newHop : newHops){
            String urn = TypeConverter.hopToURN(newHop);
            if(hopMap.containsKey(urn)){
                mergedPath.addHop(hopMap.get(urn));
            }else{
                mergedPath.addHop(newHop);
            }
        }
        if(saveToNew){
            newPathInfo.setPath(mergedPath);
        }else{
            origPathInfo.setPathType(newPathInfo.getPathType());
            origPathInfo.setPath(mergedPath);
        }
      }
}
